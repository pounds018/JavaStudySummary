## 9. 数据库:

### 9.1 服务器中的数据库:

redis服务器将所有数据库都保存在服务器状态`redis.h/redisServer结构`的db属性, db属性是一个数组每个元素都是一个`redis.h/redisDb`结构, 每一个redisDB结构代表一个数据库.

```c
struct redisServer {
    // ...
    
    // redisDb数组, 保存着服务器中的所有数据库
    redisDb *db;
    // 初始化的时候, 决定创建多少个数据库
    int dbnum;
    // ...
}
```

初始化服务器的时候, 程序会根据服务器状态的dbnum属性, 来决定应该创建多少个数据库, 即 创建多少个redisDb元素.

`dbnum属性`由服务器配置文件中`databases` 配置项来决定, 默认为16.

![image-20221115225203052](2_单机数据库的实现/image-20221115225203052.png)



### 9.2 切换数据库的实现:

![image-20221115231717391](2_单机数据库的实现/image-20221115231717391.png)

默认情况下, 客户端是连接在0号数据库上的, 客户端可用通过`SELECT`命令来切换数据库.

```sh
redis> SET msg "hello world"
redis> GET msg
"hello world"
redis> SELECT 2
redis[2]> GET msg
(nil)
```

> redis命令行不带下标表示0号库, 带下标表示几号库
>
> cluster模式中不支持select命令

**实现**

在服务器内部, 客户端状态`redisClient结构`的db属性记录了客户端当前所处的数据库, 

```c
typedef struct redisClient {
    // ...
    
    // 记录客户端当前所处的数据库
    redisDb *db
    // ...
}
```

- db属性指向redisServer.db数组其中一个元素, 默认指向下标为0的元素, select命令就是将redisClient

> 注意: `redisClient`中db属性不再是一个数组, 只是一个指向redisDb结构的指针.

**客户端从零号库切换到15号库**

![image-20221115231816072](2_单机数据库的实现/image-20221115231816072.png)





### 9.3 数据库键空间:

redis的每个数据库都是由`redis.h/redisDb结构`表示, 其中, redisDb结构中`dict属性`保存了该数据库中所有的键值对, 通常将dict属性称为`键空间`.

```c
typedef struct redisDb {
    // ...
    // 键空间, 保存了数据库中所有的键值对
    dict *dict;
    // ...
}
```

**`键空间和用户所看见的数据库是直接对应的:`**

- 键空间的键也就是数据库的键, 每一个键都是一个字符串对象.
- 键空间的值也就是数据库的值, 每一个值都可以是`字符串对象`, `列表对象`, `哈希对象`, `集合对象`, `有序集合对象`其中的一种.

![image-20221115233812164](2_单机数据库的实现/image-20221115233812164.png)

> 因为数据库实际上就是一个字典, 所以针对数据库的操作, crud实际上就是通过键空间字典的crud api来操作的



### 9.3.1 添加新键:

添加新键值对到数据库, `实际上就是在键空间字典上新增一个entry对象`, key为字符串对象, value为任意redis对象.

```sh
redis> SET date "2013.12.1"
OK
```

![image-20221115234539795](2_单机数据库的实现/image-20221115234539795.png)

### 9.3.2 删除键:

删除数据库的一个键, 实际上就是`删除字典中key为指定值得entry`.

```sh
redis> del hashtable
OK
```

![image-20221115234845151](2_单机数据库的实现/image-20221115234845151.png)



### 9.3.3 更新键:

更新一个数据库的键, 实际上`就是对key为指定值的entry中值对象进行修改`, 根据值对象的不同, 更新的具体方法有所不同.

比如:

- 值对象为字符串对象, 新值直接覆盖
- 值对象为哈希对象, 如果给定的hash对象的key不存在, 那么这个更新操作实际上是在哈希对象上新增节点, 如果hash对象的key存在, 那么这个更新操作实际上是修改hash对像key所对应值.



### 9.3.4 对键取值:

对一个数据库键进行取值, 实际上就是在键空间字典中取出键所对应的值对象, 根据值对象的类型不同, 取值方法也会有所不同.



### 9.3.5 其他键空间操作:

除了日常的crud操作外, 还有很多redis命令是对键空间进行处理来完成的.比如:

- `FLUSHDB`: 实际上就是删除键空间中所有的键值对
- `RANDOOMKEY`: 在键空间上随机返回一个键来实现的
- `DBSIZE`: 返回键空间键值对的数量



### 9.3.6 读写键空间时的维护操作:

当使用Redis命令对数据库进行crud时, 服务器不仅会对键空间执行读写操作, 还会进行一些维护操作, 就是记录一些性能相关的数据.

- 在读取一个键之后(读写都会对键空间进行读取操作), 服务器会根据键是否存在更新服务器的键空间 `命中次数` 或者 `不命中次数`.

  `INFO stats命令`返回结果中`keyspace_hits`命中次数, `keyspace_misses`不命中次数

- 在读取一个键之后, 服务器会更新键的`lru`属性, 这个值使用用于计算键的闲置时间的

- 如果服务器读取一个键时, 发现该键已经过期, 那么服务器会先删除这个键.

- 如果有客户端使用`WATCH命令`监听某个键, 那么服务器在对被监听的键进行修改之后, 会将这个键标记为`dirty`, 从而让事务程序注意到这个件已经被修改过.

- 服务器每次修改过一个键之后, 都会对dirty键计数器的值增1, 这个计数器会触发服务器的持久化以及复制操作.

- 如果服务器开启了数据库通知功能, 那么在对键进行修改之后, 服务器将按照配置发送相应的通知



### 9.4 设置键的过期时间:

`EXPIRE`,`PEXPIRE`命令, 可以以秒或者毫秒精度为数据库中的某个键设置生存时间, 在经过指定的秒数或者毫秒数之后, 服务器就会自动删除生存时间为0的键.

`EXPIREAT`, `PEXPIREAT`命令, 以秒或者毫秒进度给数据库中的某个键设置过期时间, 过期时间是个UNIX时间戳, 当键的过期时间到了, 服务器就会自动从数据库中删除这个键.

### 9.4.1 设置过期时间:

`EXPIREAT` <key> <timestamp>  将键key的过期时间设置为timestamp指定的秒数时间戳.

`PEXPIREAT`<key> <timestamp>  将键key的过期时间设置为timestamp指定的毫秒数时间戳.

`EXPIRE` <key> <ttl>  将键key的生存时间设置为ttl秒,

`PEXPIRE` <key> <ttl>  将键key的生存时间设置为ttl毫秒

> 本质上其他三个命令都是通过转化为`PEXPIREAT`命令来实现的



#### 9.4.2 保存过期时间:

redisDb结构中的`expire字典`保存了数据库中所有键的过期时间, 通常成`expire字典`为过期字典:

- 过期字典的键是一个指针, 这个指针指向键空间中的某个键对象(即数据库键), `过期字典的键和键空间的键实际上是指向同一个地址的`
- 过期字典的值是一个long long类型的整数, 这个整数保存了键所指向的数据库键的过期时间 --- 一个精确到毫秒的unix时间戳.

```c
typedef struct redisDb {
    // ...
    // 过期字典, 保存着键的过期时间
    dict *expire;
    // ...
} redisDb;
```

![image-20221116002745346](2_单机数据库的实现/image-20221116002745346.png)





#### 9.4.3 移除过期时间:

移除过期时间就是将expire字典上, 键为指定key的entry删除掉.



#### 9.4.4 计算并返回剩余生存时间:

剩余过期时间的计算, 就是在过期字典中找到指定key, 拿到value代表的过期时间, 用过期时间减去当前时间, 结果就是剩余过期时间.



#### 9.4.5 过期键的判定:

通过过期字典, 程序检查给定key是否过期的步骤为:

1. 检查给定key是否存在于过期字典中, 如果存在, 那么获得键的过期时间
2. 检查当前时间的unix时间戳是否大于过期时间: 大于则该key已经过期, 小于则没有过期

伪代码就是:

```java
public boolean isExpired(String key) {
    expireTimeMs = redisDb.expire.get(key)
	if (null == expireTimeMs) {
        return false;
    }
    if(Systen.currentTimeMs() > expirTimeMs) {
        return true;
    }
    return false
}
```

