## 1. bash的特性:

### 1. 命令和文件自动补全:

tab健只能补全`命令和文件`

### 2. 常用快捷键:

```bash
^c   			终止前台运行的程序
^z	  			将前台运行的程序挂起到后台
^d   			退出 等价exit
^l   			清屏 
^a |home  	光标移到命令行的最前端
^e |end  	光标移到命令行的后端
^u   			删除光标前所有字符
^k   			删除光标后所有字符
^r	 			搜索历史命令
```

### 3. 常用通配符:

```bash
* : 匹配0或者多个任意字符
? : 匹配单个任意字符
[list] : 匹配[list]中任意单个字符,或者一组单个字符, [a-z]
[!list] : 匹配除开 list包含字符之外的任意单个字符
{string1,string2,...} : 匹配{}中包含的所有字符串

# 通配符多用于匹配文件名:
# rm -f file*
# cp *.conf  /dir1
# touch file{1..5}
```

### 4. bash中引号的含义:

- 双引号"" : 会把引号的内容当成整体来看待, 允许通不过$符号引用其他变量

- 单引号'' : 会把引号的内容当成整体来看待, 禁止引用其他变量, shell中特殊符号都被视为普通字符

- 反撇号`` : 反撇号和$()一样，引号或括号里的命令会优先执行，如果存在嵌套，反撇号不能用 

  ![image-20210918005317806](2_linux命令总结/image-20210918005317806.png)

  > 反撇号不能嵌套使用
  >
  > ```bash
  > echo "echo `大特+%f`"
  > ```

## 2. 文本处理命令:

### 1. grep 行过滤命令:

> grep 命令是行过滤命令,用于根据关键字进行`行过滤`

#### 1. 语法与选项:

**语法:**

```bash
# []中的内容表示选填部分:
grep [选项] '关键字' 文件名
```

**选项:**

```bash
OPTIONS:
	# 常用:
	^key: 正则表达式,表示前缀匹配,以key开头的都会被选中
	key$: 正则表达式,表示后缀匹配,以key结尾的都会被选中
	-n, --line-number         输出与关键字匹配的行,同时打印行号
      --line-buffered       每行输出后刷新输出缓冲区
	-i, --ignore-case         在模式和数据中忽略大小写
      --no-ignore-case      不要忽略大小写（默认）
	-v, --invert-match  			显示与关键字不匹配的行
	-w, --word-regexp         根据关键字完全匹配,才算符合条件
	-o, --only-matching       只显示匹配的部分
	-c, --count               统计与关键字匹配的行数
	-e, --regexp=<关键字>      用指定的<关键字>字符串来进行匹配操作
	-B, --before-context=NUM  打印关键字及其前面 NUM 行
  -A, --after-context=NUM   打印关键字及其后面 NUM 行
  -C, --context=NUM         打印关键字及其前后 NUM 行
```

**颜色显示:**

在`grep命令`中加上`--color=auto`选项就可以让筛选出来的关键字有颜色,通常为了简化操作的方式如下:

```powershell
# 只针对当前终端和当前用户生效:
alias grep='grep --color=auto'

# 针对所有用户所有终端:
vim /etc/bashrc
alias grep='grep --color=auto' # 在bashrc文件中添加这句
source /etc/bashrc

# 针对某个用户生效:
vim ~/.bashrc
alias grep='grep --color=auto' # 在~/.bashrc文件中添加这句
source ~/.bashrc
```

### 2. cut 列截取命令:

> cut是列截取命令, 指定一个范围,对文件中截取文件中对应范围的字符,然后输出在终端

#### 1. 语法和选项:

**语法:**

```bash
cut [选项] 文件名
```

选项:

```bash
OPTIONS:
	# 常用:
	-d, --delimiter=分界符	 				使用指定分界符代替制表符作为区域分界,默认是'\t'
	-c, --characters=列表					 只选中指定的这些字符
	-f, --fields=列表							 只选中指定的这些域；并打印所有不包含分界符的
												 				 行，除非-s 选项被指定
  -s, --only-delimited					 不打印没有包含分界符的行
      --output-delimiter=字符串	 使用指定的字符串作为输出分界符，默认采用输入
				的分界符

```

**举例**:

```bash
# cut -d: -f1 1.txt 			以:冒号分割，截取第1列内容
# cut -d: -f1,6,7 1.txt 	以:冒号分割，截取第1,6,7列内容
# cut -c4 1.txt 				截取文件中每行第4个字符
# cut -c1-4 1.txt 			截取文件中每行的1-4个字符
# cut -c4-10 1.txt 			截取文件中每行的4-10个字符
# cut -c5- 1.txt 				从第5个字符开始截取后面所有字符
```

### 3. sort 行排序命令:

> sort 命令是对行进行排序,将文件的每一行作为一个整体,从首字符向后,依次按照ASCⅡ码值进行比较,然后按照升序排列

#### 1. 语法和选项:

```bash
-r: 降序,默认是升序
-u: 去除重复行
-n: 按照数字排序
-t: 设置分隔符
-k: 第n列
-b: 忽略前导空格
-o: 将排序结果输出到文件中
```

#### 2. 示例:

```bash
# sort -n -t: -k3 1.txt 			将每行以:分割,根据第3列,按照数字大小排序(升序)
# sort -nr -t: -k3 1.txt 			将每行以:分割,根据第3列,按照数字大小排序(降序)
# sort -n 2.txt 						按照数字排序
# sort -nu 2.txt 						按照数字排序并且去重
# sort -nr 2.txt 
# sort -nru 2.txt 
# sort -nru 2.txt 
# sort -n 2.txt -o 3.txt 			按照数字排序并将结果重定向到文件
# sort -R 2.txt 
# sort -u 2.txt 
```

### 4. uniq 去重命令:

> uniq只能去除连续的重复行.比如 第一行 1111111111111 第二行是一样的这种.且保留第一行

#### 1. 语法和选项:

```bash
-i: 忽略大小写
-c: 统计重复行次数
-d: 只显示重复行
```

### 5. tee 命令:

> tee是从 标准输入读取并写入到标准输出和文件,即: 双向(屏幕输出|文本输入)覆盖重定向

#### 1.常用参数:

```bash
-a: 追加的方式双向写入
```

> 通常与grep搭配,对筛选结果进行文件写入

### 6. diff 命令:

> diff: 逐行比较两个文件的不同

注意: diff描述两个文件不同的方式是告诉我们要怎么修改第一个文件,才能变成与第二个文件一模一样的.

#### 1. 语法与选项:

**语法:**

```bash
diff [选项] 文件1 文件2
```

**常用选项:**

```bash
-b: 不检查空格
-B: 不检查空白行
-i: 忽略大小写
-w: 所有的空格都不参与比较
--normal: 正常格式显示(默认就是--normal)
-c: 上下文格式显示
-u: 合并格式显示
-q: 比较两个目录下不同的文件有哪些
```

**示例:**

文件准备:

```bash
[root@MissHou ~]# cat file1
aaaa
111
hello world
222
333
bbb
[root@MissHou ~]#
[root@MissHou ~]# cat file2
aaa
hello
111
222
bbb
333
world
```

- 正常显示

  ```bash
  diff file1 file2 
  [root@MissHou ~]# diff file1 file2
  1c1,2					# 第一个文件的第1行需要改变(c=change)才能和第二个文件的第1到2行匹配			
  < aaaa				# 小于号"<"表示左边文件(file1)文件内容
  ---						# ---表示分隔符
  > aaa					# 大于号">"表示右边文件(file2)文件内容
  > hello
  3d3						# 第一个文件的第3行删除(d=delete)后才能和第二个文件的第3行匹配
  < hello world
  5d4						# 第一个文件的第5行删除后才能和第二个文件的第4行匹配
  < 333
  6a6,7					# 第一个文件的第6行增加(a=add)内容后才能和第二个文件的第6到7行匹配
  > 333					# 需要增加的内容在第二个文件里是333和world
  > world
  ```

- 上下文格式显示:

  ```bash
  [root@MissHou ~]# diff -c file1 file2
  # 前两行主要列出需要比较的文件名和文件的时间戳；文件名前面的符号***表示file1，---表示file2
  *** file1       2019-04-16 16:26:05.748650262 +0800
  --- file2       2019-04-16 16:26:30.470646030 +0800
  ***************	# 我是分隔符
  *** 1,6 ****		# 以***开头表示file1文件，1,6表示1到6行
  ! aaaa					# !表示该行需要修改才与第二个文件匹配
    111
  - hello world		# -表示需要删除该行才与第二个文件匹配
    222
  - 333						# -表示需要删除该行才与第二个文件匹配
    bbb
  --- 1,7 ----		# 以---开头表示file2文件，1,7表示1到7行
  ! aaa						# !表示第一个文件需要修改才与第二个文件匹配
  ! hello					# !表示第一个文件需要修改才与第二个文件匹配
    111
    222
    bbb
  + 333						# 表示第一个文件需要加上该行才与第二个文件匹配
  + world					# 表示第一个文件需要加上该行才与第二个文件匹配
  ```

- 合并格式:

  ```bash
  [root@MissHou ~]# diff -u file1 file2
  前两行主要列出需要比较的文件名和文件的时间戳；文件名前面的符号---表示file1，+++表示file2
  --- file1       2019-04-16 16:26:05.748650262 +0800
  +++ file2       2019-04-16 16:26:30.470646030 +0800
  @@ -1,6 +1,7 @@
  -aaaa
  +aaa
  +hello
   111
  -hello world
   222
  -333
   bbb
  +333
  +world
  ```

小技巧:

当需要将file1修改成file2相同时,可以对file1打补丁

```bash
1）先找出文件不同，然后输出到一个文件
[root@MissHou ~]# diff -uN file1 file2 > file.patch
-u:上下文模式
-N:将不存在的文件当作空文件
2）将不同内容打补丁到文件
[root@MissHou ~]# patch file1 file.patch
patching file file1
3）测试验证
[root@MissHou ~]# diff file1 file2
[root@MissHou ~]#
```

### 7. paste 命令:

> paste用于合并行,不会去修改源文件,而是将结果复制到标准输出流里面
>
> 合并的方式是: 讲两个文件相同行数据合并为同一行,默认使用tab分割两个文件在同一行的数据

常用选项:

```bash
-d: 自定义同一行数据之间的间隔符,默认为tab
-s: 串行处理,非并行(将第一个文件复制完毕之后再复制第二个文件)
```

### 8. tr 命令:

> 用于字符转换,替换和删除; 主要用于删除文件中控制字符串和字符转换.

#### 1.语法和选项

**语法：**

```powershell
用法1：命令的执行结果交给tr处理，其中string1用于查询，string2用于转换处理

 commands|tr  'string1'  'string2'

用法2：tr处理的内容来自文件，记住要使用"<"标准输入

 tr  'string1'  'string2' < filename

用法3：匹配string1进行相应操作，如删除操作

 tr [options] 'string1' < filename
```

**常用选项：**

```powershell
-d 删除字符串1中所有输入字符。
-s 删除所有重复出现字符序列，只保留第一个；即将重复出现字符串压缩为一个字符串
```

**常匹配字符串：**

| 字符串                | 含义                 | 备注                                              |
| --------------------- | -------------------- | ------------------------------------------------- |
| a-z或[:lower:]        | 匹配所有小写字母     | 所有大小写和数字[a-zA-Z0-9]                       |
| A-Z或[:upper:]        | 匹配所有大写字母     |                                                   |
| 0-9或[:digit:]        | 匹配所有数字         |                                                   |
| [:alnum:]             | 匹配所有字母和数字   |                                                   |
| [:alpha:]             | 匹配所有字母         |                                                   |
| [:blank:]             | 所有水平空白         |                                                   |
| [:punct:]             | 匹配所有标点符号     |                                                   |
| [:space:]             | 所有水平或垂直的空格 |                                                   |
| [:cntrl:]             | 所有控制字符         | \f Ctrl-L        走行换页<br/>\n Ctrl-J  	换行 |
| \r Ctrl-M        回车 |                      |                                                   |
| \t Ctrl-I  	tab键  |                      |                                                   |

## 3 文本处理工具:

### 1. awk:

#### 1. 概述:

- awk是一种编程语言, 主要用于在linux/unixx系统下对文本和数据处理, 是linux/unix下的一个工具. 被操作的数据可以来自标准输入, 一个或者多个文件, 或其他命令的输出
- awk处理文本和数据的方式: `逐行扫描文件`, 默认从第一行扫描到最后一行, 需找匹配的`特定模式`, 并且在这些行上面进行你想要的操作.
- gawk是awk的gun版本, 在awk的基础上进行了一些扩展.

> 下面说提到的awk都是gawk, 在linux系统中已经把awk连接到了gawk

#### 2. awk用处:

1. awk可以用来处理文件和数据, 是类unix系统下的一个工具.
2. 可以用来统计数据, 比如网站访问量, 访问的ip等等
3. 支持条件判断, 支持for和while循环

#### 3. awk的使用:

1. 语法结构:

   ```bash
   awk 选项 '命令部分' 文件
   ```

   > 如果awk命令部分要引用shell变量需要使用双引号.

2. 常用选项:

   -F : 定义字段分割符号, 默认的分隔符是空格

   -f : 指定awk要处理的脚本文件

   -V : 定义变量并赋值

3. 命令部分: `awk的语句都需要 {} 括起来`

   - `地址定位, 正则表达式`:

     ```bash
     '/root/{awk 语句}'   # 表示: 匹配/root/awk表示的语句路径
     'NR==1,NR==5{awk 语句}' # 表示扫描到第1行,第5行的时候执行awk语句,NR表示行号
     '/^root,/^ftp/{awk语句}'
     ```

   - `多条awk语句之间使用 ; 分割`

     ```bash
     'print $0;print $1'
     ```

   - `BEGIN ... END ...`: begin后面接的语句表示在begin执行前执行, end后面的语句表示在end执行之后执行

     ```bash
     'BEGIN{awk 语句1};{处理中};END{awk语句2}' # 执行过程: awk语句1,BEGIN,处理中, END, awk语句2
     'BEGIN{awk 语句1};{处理中}'
     '{处理中};END{awk语句2}'
     ```

4. 脚本模式:

   ```bash
   #!/bin/awk -f 定义魔法字符
   
   BEGIN{FS=":"}
   
   NR==1,NR==3{pring $1"\t"$NF}
   
   ....
   ```

   > 注意: 在awk脚本里面, 命令行不再需要引号括起来, 多个命令之间使用 分号 分割

   脚本执行: `awk 选项 -f awk脚本文件名称 待处理文件名称`

5. awk内建变量:

   | 变量      | 说明                                   | 备注                                                   |
   | --------- | -------------------------------------- | ------------------------------------------------------ |
   | $0        | 当前处理行的所有内容                   |                                                        |
   | $1 ... $n | 文件中每行以 `间隔符号` 分割的不同内容 | 默认间隔符号为 空格符, 注意表示的是所有行,而不是某一行 |
   | NF        | 当前记录的字段数量(列数)               |                                                        |
   | $NF       | 最后一列                               | $(NF-1)为倒数第二列                                    |
   | FNR/NR    | 表示行号                               |                                                        |
   | FS        | 定义间隔符                             | 'BEGIN{FS=":"};{print $1,$3}'                          |
   | OFS       | 定义输出字段分隔符, 默认空格           |                                                        |
   | RS        | 输入记录分隔符, 默认换行符             |                                                        |
   | ORS       | 输出记录分割符,默认换行符              |                                                        |
   |           |                                        |                                                        |
   |           |                                        |                                                        |
   |           |                                        |                                                        |

   

   
